#pragma once#include "QueType.h"QueType::QueType(int max)// Parameterized class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = max + 1;  front = maxQue - 1;  rear = maxQue - 1;  items = new ItemType[maxQue];}QueType::QueType()          // Default class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = 501;  front = maxQue - 1;  rear = maxQue - 1;  items = new ItemType[maxQue];}QueType::QueType(const QueType& que){  maxQue = 501;  front = maxQue - 1;  rear = maxQue - 1;  items = new ItemType[maxQue];}QueType::~QueType()         // Class destructor{  delete [] items;}void QueType::MakeEmpty()// Post: front and rear have been reset to the empty state.{  front = maxQue - 1;  rear = maxQue - 1;}bool QueType::IsEmpty() const// Returns true if the queue is empty; false otherwise.{  return (rear == front);}bool QueType::IsFull() const// Returns true if the queue is full; false otherwise.{  return ((rear + 1) % maxQue == front);}void QueType::Enqueue(ItemType newItem)// Post: If (queue is not full) newItem is at the rear of the queue;//       otherwise a FullQueue exception is thrown.  {  if (IsFull())    throw FullQueue();  else  {    rear = (rear +1) % maxQue;    items[rear] = newItem;  }}void QueType::Dequeue(ItemType& item)// Post: If (queue is not empty) the front of the queue has been //       removed and a copy returned in item; //       othersiwe a EmptyQueue exception has been thrown.{  if (IsEmpty())    throw EmptyQueue();  else  {    front = (front + 1) % maxQue;    item = items[front];  }}//2번void QueType::ReplaceItem2(ItemType oldItem, ItemType newItem){    EmptyQueue empty;    QueType temp;        ItemType compare;    if(rear == front){        throw empty;    }        while(!(this->rear == this->front)){        this->front = (this->front + 1) % maxQue;        compare = items[this->front];                if(compare == oldItem){            temp.Enqueue(newItem);        }        else{            temp.Enqueue(compare);        }    }        while(!(temp.front == temp.rear)){        temp.front = (temp.front + 1) % maxQue;        compare = temp.items[temp.front];                this->rear = (this->rear + 1) % maxQue;        this->items[rear] = compare;            }};//3번bool QueType::Identical2(QueType queue){    bool result;    ItemType comp1, comp2;        while(!(this->front == this->rear) || !(queue.front == queue.rear)){        this->front = (this->front + 1) % maxQue;        queue.front = (queue.front + 1) % maxQue;                comp1 = this->items[front];        comp2 = queue.items[front];                if(comp1 != comp2){            result = false;            break;        }    }        if((this->front == this->rear) && (queue.front == queue.rear)){        result = true;    }    else{        result = false;    }        return result;}//4번int QueType::Length2(){    int length = 0;    int temp = this->front;        while(!(this->front == this->rear)){        this->front = (this->front + 1) % maxQue;        length++;    }    this->front = temp; // 복원        return length;}